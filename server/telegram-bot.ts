import { storage } from "./storage";
import { predictionEngine } from "./prediction-engine";

export interface TelegramNotification {
  userId: string;
  message: string;
  type: 'prediction' | 'result' | 'subscription' | 'alert';
  matchId?: number;
  predictionId?: number;
}

export class TelegramBotService {
  private botToken: string | null = null;
  private subscribers: Map<string, { userId: string; telegramId: string; tier: string }> = new Map();

  constructor() {
    this.botToken = process.env.TELEGRAM_BOT_TOKEN || null;
    this.initializeSubscribers();
  }

  private async initializeSubscribers(): Promise<void> {
    // Load existing subscribers from database
    // This would integrate with your existing Python bot structure
  }

  async sendPredictionAlert(matchId: number, predictions: any[]): Promise<void> {
    const match = await this.getMatchById(matchId);
    if (!match) return;

    const bestPredictions = predictions
      .filter(p => parseFloat(p.confidence) > 0.80)
      .slice(0, 3);

    const message = this.formatPredictionMessage(match, bestPredictions);
    
    // Send to premium/VIP subscribers
    await this.broadcastToSubscribers(message, ['premium', 'vip']);
    
    // Log activity
    await storage.createActivityLog({
      type: "telegram_notification",
      description: `Prediction alert sent for ${match.homeTeam} vs ${match.awayTeam}`,
      metadata: { 
        matchId, 
        predictionsCount: bestPredictions.length,
        subscriberTypes: ['premium', 'vip']
      }
    });
  }

  async sendMatchResult(matchId: number, homeScore: number, awayScore: number): Promise<void> {
    const match = await this.getMatchById(matchId);
    if (!match) return;

    const predictions = await storage.getPredictions(matchId);
    const correctPredictions = predictions.filter(p => p.isCorrect === true);
    const accuracy = predictions.length > 0 ? (correctPredictions.length / predictions.length) * 100 : 0;

    const message = this.formatResultMessage(match, homeScore, awayScore, accuracy);
    
    // Send to all subscribers
    await this.broadcastToSubscribers(message, ['free', 'premium', 'vip']);
  }

  private formatPredictionMessage(match: any, predictions: any[]): string {
    let message = `üîÆ **AI Prediction Alert**\n\n`;
    message += `‚öΩ **${match.homeTeam} vs ${match.awayTeam}**\n`;
    message += `üèÜ League: ${match.league}\n`;
    message += `‚è∞ Starts: ${new Date(match.scheduledTime).toLocaleTimeString()}\n\n`;
    
    message += `üìä **Top Predictions:**\n`;
    predictions.forEach((pred, index) => {
      const confidence = (parseFloat(pred.confidence) * 100).toFixed(1);
      message += `${index + 1}. ${pred.predictionType.replace('_', ' ').toUpperCase()}: ${pred.prediction} (${confidence}%)\n`;
    });
    
    message += `\nü§ñ Generated by ${predictions[0]?.mlModel || 'AI'} model`;
    message += `\nüì± Platform: ${match.platform.toUpperCase()}`;
    
    return message;
  }

  private formatResultMessage(match: any, homeScore: number, awayScore: number, accuracy: number): string {
    let message = `‚úÖ **Match Result**\n\n`;
    message += `‚öΩ **${match.homeTeam} ${homeScore}-${awayScore} ${match.awayTeam}**\n`;
    message += `üèÜ ${match.league}\n\n`;
    message += `üéØ **Prediction Accuracy: ${accuracy.toFixed(1)}%**\n`;
    message += `üìä Our AI models successfully predicted this outcome\n`;
    message += `\nüî• Keep following for more winning predictions!`;
    
    return message;
  }

  private async broadcastToSubscribers(message: string, tiers: string[]): Promise<void> {
    // Integration point with your existing Python Telegram bot
    // This would send HTTP requests to your bot endpoint or use direct API calls
    
    console.log(`üì® Broadcasting message to ${tiers.join(', ')} subscribers:`);
    console.log(message);
    
    // Log the broadcast
    await storage.createActivityLog({
      type: "telegram_broadcast",
      description: `Message broadcasted to ${tiers.join(', ')} tier subscribers`,
      metadata: { message: message.substring(0, 100), tiers }
    });
  }

  private async getMatchById(matchId: number): Promise<any> {
    const matches = await storage.getMatches(100);
    return matches.find(m => m.id === matchId);
  }

  // Subscription management methods
  async subscribeUser(userId: string, telegramId: string, tier: string = 'free'): Promise<void> {
    this.subscribers.set(userId, { userId, telegramId, tier });
    
    await storage.createUserSubscription({
      userId,
      tier,
      startDate: new Date(),
      endDate: tier === 'free' ? undefined : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
      platforms: JSON.stringify(['sportybet', 'bet365', '1xbet']),
      preferences: JSON.stringify({ telegramId, notifications: true })
    });
  }

  async updateSubscription(userId: string, newTier: string): Promise<void> {
    const subscriber = this.subscribers.get(userId);
    if (subscriber) {
      subscriber.tier = newTier;
      this.subscribers.set(userId, subscriber);
    }
  }

  getSubscriberCount(): { free: number; premium: number; vip: number } {
    const counts = { free: 0, premium: 0, vip: 0 };
    this.subscribers.forEach(sub => {
      if (sub.tier in counts) {
        (counts as any)[sub.tier]++;
      }
    });
    return counts;
  }
}

export const telegramBot = new TelegramBotService();